import Data.List (permutations)
import Data.List (tails)

prime :: Int -> Bool
prime n
  | n <= 1    = False
  | otherwise = not (any (\x -> n `mod` x == 0) [2..n-1])
  
combinations :: Int -> [a] -> [[a]] --debug
combinations 0 _  = [[]]
combinations _ [] = []
combinations k (x:xs) = map (x:) (combinations (k-1) xs) ++ combinations k xs
 
generator2 :: [[Int]]
generator2 = filter isInOrder(concatMap permutations (combinations 4 [3,5,7,11,13,17,19,23,29,31,37,41]))

isInOrder :: [Int] -> Bool
isInOrder [a,b,c,d] = a < b && b < c && c < d

canPlay :: Int -> [Int] -> Bool
canPlay total remainingTiles =
    all (\(a, b) -> prime (total + a + b)) pairs
  where
    pairs = [(x, y) | x <- remainingTiles, y <- remainingTiles, x < y]
    
fourCombinations :: [a] -> [[a]]
fourCombinations xs = [ [a,b,c,d] | 
    (a:rest1) <- tails xs,
    (b:rest2) <- tails rest1,
    (c:rest3) <- tails rest2,
    (d:_)     <- tails rest3 ]
    
situationWhereAnnCantPlay :: [Int] -> [Int] -> Bool
situationWhereAnnCantPlay remainingNumbers playedNumbers =
    let ps = sum (take 4 playedNumbers) + 3
        invalidHands = [ h | h <- fourCombinations remainingNumbers,
                        not (prime (h!!0 + h!!1 + 3)) &&
                        not (prime (h!!0 + h!!2 + 3)) &&
                        not (prime (h!!0 + h!!3 + 3)) &&
                        not (prime (h!!1 + h!!2 + 3)) &&
                        not (prime (h!!1 + h!!3 + 3)) &&
                        not (prime (h!!2 + h!!3 + 3)) ]
        fullyInvalidHands = [ h | h <- invalidHands,
                        not (prime (h!!0 + h!!1 + ps)) &&
                        not (prime (h!!0 + h!!2 + ps)) &&
                        not (prime (h!!0 + h!!3 + ps)) &&
                        not (prime (h!!1 + h!!2 + ps)) &&
                        not (prime (h!!1 + h!!3 + ps)) &&
                        not (prime (h!!2 + h!!3 + ps)) ]
    in length fullyInvalidHands > 0

selector2 :: [Int] -> Bool
selector2 xs =
    any checkOne (permutations xs)
  where
    checkOne [a,b,c,d] =
        let remainingTiles = filter (`notElem` [a, b, c, d]) [3,5,7,11,13,17,19,23,29,31,37,41]
        in
            --not (canPlay 3 remainingTiles) &&
            --not (canPlay (3 + a + b + c + d) remainingTiles) &&
            situationWhereAnnCantPlay remainingTiles [a,b,c,d] &&
            prime (3 + a + b) &&
            prime (3 + a + b + c + d)
    checkOne _ = False

x_ :: Bool -> Int -> Int
x_ True n  = n + 1
x_ False n = n

x_warmup2 :: Int
x_warmup2
  = n5
    where
      n1 = x_ ( prime 13) 0
      n2 = x_ ( prime 43) n1
      n3 = x_ ( prime 199) n2
      n4 = x_ ( prime 439) n3
      n5 = x_ ( prime 691) n4

x_generator2 :: Int
x_generator2
  = n5
    where
      n1 = x_ ([3 ,5 ,7 ,13] `elem` generator2 ) 0
      n2 = x_ ([3 ,7 ,17 ,41] `elem` generator2 ) n1
      n3 = x_ ([3 ,13 ,23 ,29] `elem` generator2 ) n2
      n4 = x_ ([5 ,7 ,13 ,23] `elem` generator2 ) n3
      n5 = x_ ([5 ,11 ,29 ,41] `elem` generator2 ) n4

x_selector2 :: Int
x_selector2
  = n5
    where
        n1 = x_ ( selector2 [7 ,23 ,31 ,37]) 0
        n2 = x_ ( selector2 [23 ,7 ,37 ,31]) n1
        n3 = x_ (not ( selector2 [2 ,3 ,5 ,7]) ) n2
        n4 = x_ (not ( selector2 [5 ,11 ,29 ,41]) ) n3 -- issue
        n5 = x_ (not ( selector2 [1 ,3 ,5 ,9]) ) n4
        
x__selector2 :: Int
x__selector2
  = n1
    where
      n1 = x_ ( ( selector2 [7 ,23 ,31 ,37]) ) 0

main :: IO ()
main = print ( head ( filter selector2 generator2 ))
