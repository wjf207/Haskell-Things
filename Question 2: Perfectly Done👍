import Data.List (permutations)

prime :: Int -> Bool
prime n
  | n <= 1    = False
  | otherwise = not (any (\x -> n `mod` x == 0) [2..(n-1)])
  
combinations :: Int -> [a] -> [[a]] -- re-worked GPT code https://chatgpt.com/s/t_68f4dca83d3c8191b8cb843d470b6a47
combinations 0 _  = [[]]
combinations _ [] = []
combinations k (x:xs)
  | k < 0     = []
  | otherwise = withX ++ withoutX
  where
    withX    = map (x:) (combinations (k-1) xs)
    withoutX = combinations k xs
 
generator2 :: [[Int]]
generator2 = filter isInOrder(concatMap permutations (combinations 4 [3,5,7,11,13,17,19,23,29,31,37,41]))

isInOrder :: [Int] -> Bool
isInOrder [a,b,c,d] = a < b && b < c && c < d
  
situationWhereAnnCantPlay :: [Int] -> [Int] -> Bool
situationWhereAnnCantPlay remainingTiles playedTiles =
    let ps = sum (take 4 playedTiles) + 3
        invalidHands = [ h | h <- combinations 4 remainingTiles, -- https://stackoverflow.com/questions/5217171/how-can-i-get-nth-element-from-a-list
                        not (prime (h!!0 + h!!1 + 3)) &&
                        not (prime (h!!0 + h!!2 + 3)) &&
                        not (prime (h!!0 + h!!3 + 3)) &&
                        not (prime (h!!1 + h!!2 + 3)) &&
                        not (prime (h!!1 + h!!3 + 3)) &&
                        not (prime (h!!2 + h!!3 + 3)) ]
        fullyInvalidHands = [ h | h <- invalidHands,
                        not (prime (h!!0 + h!!1 + ps)) &&
                        not (prime (h!!0 + h!!2 + ps)) &&
                        not (prime (h!!0 + h!!3 + ps)) &&
                        not (prime (h!!1 + h!!2 + ps)) &&
                        not (prime (h!!1 + h!!3 + ps)) &&
                        not (prime (h!!2 + h!!3 + ps)) ]
    in length fullyInvalidHands > 0

selector2 :: [Int] -> Bool
selector2 xs =
    any checkOne (permutations xs)
  where
    checkOne [a,b,c,d] =
        let remainingTiles = filter (`notElem` [a, b, c, d]) [3,5,7,11,13,17,19,23,29,31,37,41]
        in
            situationWhereAnnCantPlay remainingTiles [a,b,c,d] &&
            prime (3 + a + b) &&
            prime (3 + a + b + c + d)
    checkOne _ = False

x_ :: Bool -> Int -> Int
x_ True n  = n + 1
x_ False n = n

x_warmup2 :: Int
x_warmup2
  = n5
    where
      n1 = x_ ( prime 13) 0
      n2 = x_ ( prime 43) n1
      n3 = x_ ( prime 199) n2
      n4 = x_ ( prime 439) n3
      n5 = x_ ( prime 691) n4

x_generator2 :: Int
x_generator2
  = n5
    where
      n1 = x_ ([3 ,5 ,7 ,13] `elem` generator2 ) 0
      n2 = x_ ([3 ,7 ,17 ,41] `elem` generator2 ) n1
      n3 = x_ ([3 ,13 ,23 ,29] `elem` generator2 ) n2
      n4 = x_ ([5 ,7 ,13 ,23] `elem` generator2 ) n3
      n5 = x_ ([5 ,11 ,29 ,41] `elem` generator2 ) n4

x_selector2 :: Int
x_selector2
  = n5
    where
        n1 = x_ ( selector2 [7 ,23 ,31 ,37]) 0
        n2 = x_ ( selector2 [23 ,7 ,37 ,31]) n1
        n3 = x_ (not ( selector2 [2 ,3 ,5 ,7]) ) n2
        n4 = x_ (not ( selector2 [5 ,11 ,29 ,41]) ) n3 -- issue
        n5 = x_ (not ( selector2 [1 ,3 ,5 ,9]) ) n4
        
x__selector2 :: Int
x__selector2
  = n1
    where
      n1 = x_ ( ( selector2 [7 ,23 ,31 ,37]) ) 0

main :: IO ()
main = print ( head ( filter selector2 generator2 ))
