import Data.List (nub)

x_ :: Bool -> Int -> Int
x_ b n = if b then n + 1 else n

number :: [Int] -> Int
number [] = 0
number digits = foldl (\acc d -> acc * 10 + d) 0 digits

noRepeats :: Int -> Bool
noRepeats n = 
    let digits = show n 
        unique = nub digits
    in length digits == length unique

hasZero :: Int -> Bool
hasZero n =
    let digits = show n
    in '0' `elem` digits

inOrder :: Int -> Bool
inOrder n = 
    let digits = show n
        last3  = drop 3 digits
        [a,b,c] = map (\ch -> read [ch] :: Int) last3
    in a >= b && b >= c

followsRule :: Int -> Bool
followsRule n =
    let digits = show n
        [a,b,c,d,e,f] = map (\ch -> read [ch] :: Int) digits
    in (a+b+c+d+e+f) == (5*(a+f))
    
isSquare :: Int -> Bool 
isSquare n =
  (floor (sqrt (fromIntegral n))) * (floor (sqrt (fromIntegral n))) == n
    
    
generator1 :: [(Int,Int,Int,Int,Int,Int)]
generator1 =
  [ (a,b,c,d,e,f) |
    a <- [1..9], 
    b <- [1..9], 
    c <- [1..9], 
    d <- [1..9], 
    e <- [1..9], 
    f <- [1..9],
    length (nub [a,b,c,d,e,f]) == 6 --ChatGPT showed me nub 07/10/25
  ]

selector1 :: (Int,Int,Int,Int,Int,Int) -> Bool
selector1 (a,b,c,d,e,f) =
    let n = read (concatMap show [a,b,c,d,e,f]) :: Int
    in noRepeats n &&
      not (hasZero n) &&
      inOrder n &&
      isSquare n &&
      followsRule n
    
    
x_warmup1 :: Int
x_warmup1
  = n5
    where
    n1 = x_ ( number [] == 0) 0
    n2 = x_ ( number [2 ,7] == 27) n1
    n3 = x_ ( number [5 ,4 ,1] == 541) n2
    n4 = x_ ( number [0 ,2 ,4] == 24) n3
    n5 = x_ ( number [1 ,7 ,0 ,6] == 1706) n4

x_generator1 :: Int
x_generator1
  = n5
    where
    n1 = x_ ((1 ,3 ,4 ,6 ,2 ,5) `elem` generator1 ) 0
    n2 = x_ ((1 ,6 ,3 ,4 ,2 ,5) `elem` generator1 ) n1
    n3 = x_ ((2 ,1 ,5 ,6 ,3 ,4) `elem` generator1 ) n2
    n4 = x_ ((3 ,2 ,4 ,9 ,1 ,5) `elem` generator1 ) n3
    n5 = x_ ((3 ,6 ,8 ,9 ,1 ,2) `elem` generator1 ) n4


x_selector1 :: Int
x_selector1
  = n5
    where
    n1 = x_ ((selector1(4,3,6,9,2,1))) 0
    n2 = x_ (not(selector1(1,2,9,6,3,4))) n1
    n3 = x_ (not(selector1(2,1,4,3,6,9))) n2
    n4 = x_ (not(selector1(9,2,1,4,3,6))) n3
    n5 = x_ (not(selector1(2,9,4,6,3,4))) n4


main :: IO ()
main = print(  head ( filter selector1 generator1 ) )
